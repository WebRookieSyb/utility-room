### 面向对象的六大原则（SOLID）---待后续补充完善

* 单一职责原则（SRP）
    一个类只允许有一个职责，即只有一个导致该类变更的原因。
    > 换句话说就是让一个类只做一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。在所有的SOLID原则中，这是大多数开发人员感到最能完全理解的一条。严格来说，这也可能是违反最频繁的一条原则了。单一责任原则可以看作是低耦合、高内聚在面向对象原则上的引申，将责任定义为引起变化的原因，以提高内聚性来减少引起变化的原因。责任过多，可能引起它变化的原因就越多，这将导致责任依赖，相互之间就产生影响，从而极大的损伤其内聚性和耦合度。单一责任，通常意味着单一的功能，因此不要为一个模块实 现过多的功能点，以保证实体只有一个引起它变化的原因。

    放在js的背景下，可能我们更应该注意的是函数的单一职责原则（毕竟函数式一等公民），比如简单的拼接参数、发送接口然后处理返回值，很多时候我们就会将这个过程写成一个函数，在条件允许情况下，将这个请求函数按照相应职责分为多个功能单一的函数可能会提高你代码的可读性和维护性。对于类来说那就是,请求类的职责就是请求，不要把拼接参数和处理返回值这两个不属于他的职责作为方法放在请求类中。

* 开闭原则（OCP）
    类、模块和函数应该对扩展开放，对修改关闭。
    > 对扩展开放是为了应对需求变化，对修改关闭是为了保证原有代码的稳定性。也就是说,我们在设计一个系统/模块/功能的时候,应当使这个模块可以在不被修改的前提下被扩展,也就是应当可以在不必修改源代码的情况下改变这个系统/模块/功能的行为.
    对扩展开放是为了应对需求变化，对修改关闭是为了保证原有代码的稳定性。在识别出代码可变部分和不可变部分之后，要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层使用。常见的多态、面相接口编程、依赖注入，以及大部分设计模式（比如：装饰、策略、模板、职责链、状态等）都是开闭原则的表现。

* 里氏替换原则（LSP）
    所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类对象可以替换其父类对象，而程序执行效果不变。
    > 满足LSP的子类在设计的时候有哪些要求呢？1.子类可以增加自己特有的属性和方法子类，也可以实现父类的抽象方法。2.要么不能复写父类的非抽象方法，否则在覆写父类方法的时候，输入输出必须遵从父类的约定。输入相同或者更宽松，输出相同或者更严格。比如子类参数的类型包含父类参数的类型。

    里氏替换原则可以检验继承使用的正确性，约束继承在使用上的泛滥。
    ```javascript
    class Retry {
      public async call(fn) {
        for(let attemptNumber = 1;; attemptNumber++) {
          try{
            const response = await fn();
          } catch(error) {
            throw Error('error');
          }

          if (response.code < 500) {
            return response;
          }
        }
      }
    }

    class BaseRetry extends Retry{
      public async call(fn) {
        for(let attemptNumber = 1;; attemptNumber++) {
          try{
            const response = await fn();
          } catch(error) {
            throw Error('error');
          }

          if (response.code < 500) {
            response.attemptNumber = attemptNumber;
            return response;
          }
        }
      }
    }
    ```
    上面是一个接口重试的例子（当然这里实现非常的简洁，只是通过它来看一下LSP），如果返回的code值小于500就返回结果，否则继续重试。子类BaseRetry对返回的结果做了增强，用它来替换new Retry().call()的运行完全没有问题。但如果反过来，BaseRetry是父类，Retry是子类，Retry替换BaseRetry就可能引起异常，因为子类Retry中取不到attemptNumber，子类对父类的返回值做了删减。

* 接口隔离原则（ISP）
    多个特定的客户端接口要好于一个通用性的总接口。
    > * 客户端不应该依赖它不需要实现的接口。
    > * 不建立庞大臃肿的接口，应尽量细化接口，接口中的方法应该尽量少。
    
    接口隔离原则可以避免同一个接口里面包含不同类职责的方法，接口责任划分更加明确，符合高内聚低耦合的思想。由于js的「鸭子类型」，js当中的接口只是一种隐性的契约而已。所以在js中比较典型的例子就是那些需要大量配置信息的类。其实使用者并不需要去关心每一个配置项，不强制他们设置大量的选项能够节省大量的时间，保持设置选项的可选性能够有助于防止「胖接口」。


* 依赖倒置原则（DIP）
    1. 上层模块不需要依赖下层模块，两者依赖于抽象。
    2. 抽象不应该依赖于细节。细节应当依赖于抽象。
    > 实现方向
    > * 针对接口编程，而不是针对实现编程。
    > * 尽量不要从具体的类派生，而是以继承抽象类或实现接口来实现。
    > * 关于高层模块与低层模块的划分可以按照决策能力的高低进行划分。业务层自然就处于上层模块，逻辑层和数据层自然就归类为底层。

    依赖倒置原则的实现体现在面相接口编程中，js本身没有接口，从而抽象只能依赖于隐性的契约。也就是指，一个对象/类所暴露给另一个对象/类的方法和属性。


