## 插件系统
插件是现在的库的常见功能，允许开发者去拓展功能而无需影响主库本身。插件本身是一种编程思想，宽泛点来说不仅仅像webpack、bable中，而且react 的生命周期，koa的中间件，甚至业务代码用到的request处理我们都可以看做是插件思想的实现。

## 插件系统的类型
* 约定/注入插件化
按照某个约定来设计插件，这个约定一般是：入口文件/指定文件名作为插件入口，文件形式.json/.ts 不等，只要返回的对象按照约定名称书写，就会被加载，并可以拿到一些上下文。

* 事件插件化
通过事件的方式提供插件开发的能力。

通常来说，很多插件系统都将这两者结合使用


## 插件注册
### 插件注册方式
* 通过 npm 注册：比如只要 npm 包符合某个前缀，就会自动注册为插件，这个很简单，不举例子了。
* 通过文件名注册：比如项目中存在 xx.plugin.ts 会自动做到插件引用，当然这一般作为辅助方案使用。
* 通过代码注册：这个很基础，就是通过代码 require 就行，比如 babel-polyfill，不过这个要求插件执行逻辑正好要在浏览器运行，场景比较受限。

* 通过描述注册：比如在 package.json 描述一个属性，表明了要加载的插件，比如 .babelrc:
```
{
  "presets": ["es2015"]
}
```
* 自动注册：比较暴力，通过遍历可能存在的位置，只要满足插件约定的，会自动注册为插件。这个行为比较像 require 行为，会自动递归寻找 node_modules，当然别忘了像 require 一样提供 paths 让用户手动配置寻址起始路径。

### 插件注册实现
babel通过在配置文件中注册，然后babel通过require来引用插件

webpack是我们自己在webpack配置文件中引入插件，然后new到plugins配置中，内部通过调用apply方法传入Compiler和Compilation,Compiler和Compilation都继承自Tapable，可以直接在Compiler和Compilation对象上广播和监听事件

## 插件生命周期
确定插件注册方式后，一般第一件事就是加载插件，后面就是根据框架业务逻辑不同而不同的生命周期了，插件在这些生命周期中扮演不同的功能，我们需要通过一些方式，让插件能够影响这些过程。

## 插件之间的依赖
插件之间难免有依赖关系，目前有两种方式处理，分为：依赖关系定义在业务项目中，与依赖关系定义在插件中。

稍微解释下，依赖关系定义在业务项目中，比如 webpack 的配置，我们在业务项目里是这么配的：
```
{
  "use": ["babel-loader", "ts-loader"]
}
```
在 webpack 中，执行逻辑是 ts-loader -> babel-loader，当然这个规则由框架说了算，但总之插件加载执行肯定有个顺序，而且与配置写法有关，而且配置需要写在项目中（至少不在插件中）。
另一种行为，将插件依赖写在插件中，比如 webpack-preload-plugin 就是依赖 html-webpack-plugin。
这两种场景各不同，一个是业务有关的顺序，也就是插件无法做主的业务逻辑问题，需要把顺序交给业务项目配置；一种是插件内部顺序，也就是业务无需关心的顺序问题，由插件自己定义就好啦。注意框架核心一般可能要同时支持这两种配置方式，最终决定插件的加载顺序。


## 插件通信
插件之间通信也可以通过 hook 或者 context 方式支持，hook 主要传递的是时机信息，而 context 主要传递的是数据信息，但最终是否能生效，取决于上面说到的插件加载顺序。

* context 可以拿 react 做个类比，一般都有作用域的，而且与执行顺序严格相关。
* hook 等于插件内部的一个事件机制，由一个插件注册

### 参考文章
* [精读《插件化思维》](https://juejin.im/post/6844903597386235912)
* [如何设计一个js插件系统](https://segmentfault.com/a/1190000023855763)