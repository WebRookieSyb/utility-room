### 面相对象的javascript

#### 动态语言类型和鸭子类型
编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言。静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。

静态类型语言的优点首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前 避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译 器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。

动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。JavaScript就是一门典型的动态类型语言。

鸭子类型：

在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们 不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则:“面向接口编程，而不是面向实现编程”。例如，一个对象若有`push`和`pop`方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有`length`属性，也可以依照下标来存取属性，这个对象就可以被当作数组来使用。

在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或 者接口等将对象进行向上转型。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在类 型检查系统的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象 多态性的价值。

#### js中的多态
多态的实际含义是:同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结 果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。

多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事 物”与 “可能改变的事物”分离开来。比如动物都会叫，这是不变的，但是不同类 型的动物具体怎么叫是可变的。把不变的部分隔离出来，把可变的部分封装起来，这给予了我们 扩展程序的能力，程序看起来是可生长的，也是符合开放—封闭原则的，相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全得多。

```
// 把不变的隔离出来，所有的动物都会发出叫声
var makeSound = function( animal ){ 
  animal.sound();
};

// 可变部分各自封装
var Duck = function(){}
Duck.prototype.sound = function(){ 
  console.log( '嘎嘎嘎' );
};

var Chicken = function(){}
Chicken.prototype.sound = function(){ 
  console.log( '咯咯咯' );
};

makeSound( new Duck() ); // 嘎嘎嘎
makeSound( new Chicken() ); // 咯咯咯
```
在静态语言中由于类型检查的的原因，通常向上转型（继承）来实现多态（Duck对象和Chicken对象的类型都被隐藏在超类型 Animal 身后，Duck 对象和 Chicken 对象就能被交换使用）而 JavaScript 的变量类型在运行期是可变的。一个 JavaScript 对象，既可以表示 Duck 类型的对象，又可以表示 Chicken 类型的对象，这意味着 JavaScript 对象的多态性是与生俱来的。

这种与生俱来的多态性并不难解。JavaScript 作为一门动态类型语言，它在编译时没有类型检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型。在上面的例子中，我们既可以往makeSound 函数里传递 duck 对象当作参数，也可以传递 chicken 对象当作参数。由此可见，某一种动物能否发出叫声，只取决于它有没有 makeSound 方法，而不取决于它是 否是某种类型的对象，这里不存在任何程度上的“类型耦合”，这正式之前的鸭子类型所指。

#### js中的封装
* 封装数据：在许多语言的对象系统中，封装数据是由语法解析来实现的，这些语言也许提供了private、public、protected 等关键字来提供不同的访问权限。但 JavaScript 并没有提供对这些关键字的支持，我们只能依赖变量的作用域来实现封装特性。通常使用let、const、闭包等来实现。

* 封装实现：从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。 对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的 API 接口来通信。当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。

* 封装类型: 一般而言，封装类型是通过抽象类和接口来进行的把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为。在许多静态语言的设计模式中，想方设法地去隐藏对象的类型，也是促使这些模式诞生的原因之一。比如工厂方法模式、组合模式等。当然在 JavaScript 中，并没有对抽象类和接口的支持。JavaScript 本身也是一门类型模糊的语言。在封装类型方面，JavaScript 没有能力。

* 封装变化：通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变
过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。

#### 基于原型继承的js对象系统

在用 Java 等静态类型语言编写程序的时候，类型之间的解耦非常重要。依赖倒置原则提醒 我们创建对象的时候要避免依赖具体类型，而用 new XXX 创建对象的方式显得很僵硬。工厂方法 模式和抽象工厂模式可以帮助我们解决这个问题，但这两个模式会带来许多跟产品类平行的工厂 类层次，也会增加很多额外的代码。原型模式提供了另外一种创建对象的方式，通过克隆对象，我们就不用再关心对象的具体类型名字。

JavaScript 本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的。所以在js中原型模式更像是一种编程范式。

原型编程范式拥有着以下几个规则
1. 所有的数据都是对象。
在js中除了 undefined 之外，一切都应是对象。为了实现这一目标，number、boolean、string 这几种基本类型数据也可以通过“包装类”的方式变成对象类型数据来处理。JavaScript中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的。
2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。
JavaScript 的函数既可以作为普通函数被调用，也可以作为构造器被调用。当使用`new`运算符来调用函数时，此时的函数就是一个构造器。用`new`运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额 外操作的过程。
```
// new简单实现
function myNew(Con, ...args) {
  // 创建空对象
  let obj = {}
  // Object.setPrototypeOf(obj, Con.prototype)
  // 原型链指向构造函数的原型
  obj.__proto__ = Con.prototype;
  // 绑定this并执行构造函数
  let result = Con.apply(obj, args)
  // 确认返回一个对象
  return typeof result === "object" ? result : obj
}
```
也可以使用Object.create()创建
```
// create简单实现
function myCreate (proto) {
  function F() {}
  F.prototype = proto;
  return new F();
}
```

3. 对象会记住它的原型。
就 JavaScript 的真正实现来说，其实并不能说对象有 原型，而只能说对象的构造器有原型。对于“对象把请求委托给它自己的原型”这句话，更好 的说法是对象把请求委托给它的构造器的原型。JavaScript 给对象提供了一个名为__proto__的属性，某个对象的__proto__属性默认会指 向它的构造器的原型对象
4. 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。
在 JavaScript 中，每个对象都是从 Object.prototype 对象克隆而来的，如果是这样的话， 我们只能得到单一的继承关系，即每个对象都继承自 Object.prototype 对象，这样的对象系统显然是非常受限的。实际上，虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造 器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。这样一来，当对象 a 需 要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的 效果。
```
var A = function(){}; A.prototype = { name: 'sven' };
var B = function(){}; B.prototype = new A();
var b = new B();
console.log( b.name ); // 输出:sven
```

#### js面相对象的未来

JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。JavaScript 也没有在语言层面提供对抽象类和接口的支持。这些跟传统面向对象语言不一致的地方在未来的发展中也会逐渐被ES新版本及typescript所实现，在写法上越来越像传统的面相对象语言，但是所有的这些都是基于原有js的语法糖（最终都被babel等打包成了ES5），并且js同时也拥有许多函数式语言的特性（闭包、高阶函数等），如何使用取决于具体情况。


