### 面向过程（OPP）、面向对象（OOP）、面向切面（APP）、面相接口（IOP）

* 面向过程编程 OPP：Procedure Oriented Programming，是一种以事物为中心的编程思想。主要关注 “怎么做”，即完成任务的具体细节。

* 面向对象编程 OOP：Object Oriented Programming，是一种以对象为基础的编程思想。主要关注 “谁来做”，即完成任务的对象。  

* 面向切面编程 AOP：Aspect Oriented Programming，基于 OOP 延伸出来的编程思想。主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。

* 面向接口编程 AOP：Interface Oriented Programming，也是基于 OOP 延伸出来的编程思想。接口是程序中的抽象表示，面相接口编程使得高层模块不依赖底层模块，而依赖于抽象，从而达到了解耦的目的

四者并非同一层级的概念，面相切面及面相接口是附属于面向对象思想体系，属于其一部分，四者放在一处只是因为命名类似，容易混淆罢了。

> 每种编程思想都有各自的优点，它们适用在不同的情况下：面向过程性能很高，面向对象比较易于管理和维护，面向切面使软件变得更灵活。
> 
> 新的编程范式，并不一定完全各方面都优于旧的编程范式，它们只是在某一特定领域或特殊场景下有着独到的优势。
> 
> 编程范式只有适合不适合项目特性，没有绝对的好坏。

#### OPP 和 OOP

面向过程是最为实际的一种思考方式，就算是[面向对象](https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1)的方法也是含有面向过程的思想。可以说面向过程是一种基础的方法。它考虑的是实际地实现。一般的面向过程是从上往下步步求精，所以面向过程最重要的是模块化的思想方法。当程序规模不是很大时，面向过程的方法还会体现出一种优势。因为程序的流程很清楚，按着模块与函数的方法可以很好的组织。

面向对象是基于对象概念，以对象为中心，以类和继承为构造机制，来认识、理解、刻画客观世界和设计、构建相应的软件系统。类和继承是是适应人们一般思维方式的描述范式。方法是允许作用于该类对象上的各种操作。这种对象、类、消息和方法的程序设计范式的基本点在于对象的封装性和类的继承性。通过封装能将对象的定义和对象的实现分开，通过继承能体现类与类之间的关系，以及由此带来的[动态联编](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96)和实体的多态性。


面向对象思想的核心之一，就是模拟真实世界，把真实世界中的事物抽象成类，整个程序靠各个类的实例互相通信、互相协作完成系统功能，这非常符合真实世界的运行状况，也是面向对象思想的精髓。

### 举个栗子：

比如完成 “吃饭” 这个任务。

#### 面向过程的写法，需要封装一个 eat() 函数：

如果是狗吃屎，则 eat(狗, 屎)；

如果是人吃肉，则 eat(人, 肉)；

eat 是人和狗共用的吃饭本能。

那如果之后要处理猫吃鱼、鱼吃虾、奥特曼吃小怪兽呢？eat 函数中就会存在大量的 if…else 的判断，这段代码，无疑是很恶心的。

#### 如果是面向对象思想，如何来解决这个问题呢？

我们发现，狗、人、猫、鱼、奥特曼，都有一个 “吃” 的共性。我们抽象出每个受体的类，然后继承，这样都具有 “吃” 的方法。

当我们想要执行狗吃屎时，那就 “狗 ->eat(屎)”，这样，我们从面向过程维护 eat() 的焦点，转移到了面向对象维护角色的焦点上来。我们只需要维护好不同的角色（类）就好了，并且狗的 eat 不会影响到猫的 eat，猫的 eat 也不会影响到人的 eat。

#### 所以，oop 思想非常贴近软件工程高内聚的思想：自己管好自己的东西，自己做好自己的事情。

> 大多数支持面向对象的语言，同时也支持面向过程，不论是 JAVA、PHP，还是 JS，它们都还无法完全面向对象，因为面向过程是必然的，面向过程代表着必要的程序流程，调动对象进行组合或对象内部能力的实现，都一定会存在 “过程”，它最终还是需要通过拆分步骤来指导最具体的执行细节。
> 
> 在此，我们也能得到一些感悟，许多事情并非完全非黑即白，非 OOP 就必然是 OPP，特别是思想层面的东西，它们呈现出互相结合的形态，从 OPP 到 OOP，这是一个思想进步的过程。

### AOP

面向切面编程主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低[耦合性](https://baike.baidu.com/item/%E8%80%A6%E5%90%88%E6%80%A7)的隔离效果。  

#### 那么，AOP 如何体现？

这里可以联想一下 laravel 中间件、koa 的中间件、javaweb 的拦截器，redux中间件。它们都是 AOP 思想的实践。装饰器模式、代理模式，它们也是基于 AOP 思想的设计模式。

AOP 思想，指导我们通过找到平整切面的形式，插入新的代码，使新插入的代码对切面上下原有流程的伤害降到最低。

举个栗子：
-----

我们拿 laravel 中间件做什么？

权限、日志、请求过滤、请求频率限制、csrf 过滤……。我们知道，中间件对于 controller 的业务逻辑，不会有任何伤害。

如果没有这个切面，我们想要记录请求日志，可能需要在每个 controller 的具体方法中写日志记录的代码，或者调用日志记录的函数、方法。这会使一段记录日志的代码，或调用记录日志的调用语句出现在许多 controller 中，这与 controller 原本要关注的逻辑无关，使 controller 职责不单一，提高维护成本。

当然，我们可能会写一个父类，让许多 controller 来继承这个父类，然后统一在父类的\_\_construct 方法中记录日志，以此来解决耦合问题。

但实际上，这个父类的 construct 方法，不正是一个切面吗？它在原有流程中截取了一个切面，在切面中植入代码，以达到承上启下的作用，并且不对上下文产生伤害。

从这个例子中，我们也能得出另外一个思考：AOP 指导我们寻找切面，但找到合适的切面，也尤为重要。就像上文，父类构造函数的切面和中间件的切面比起来，显然中间件这个切面更利于维护，你可以灵活选择中间件，但你无法灵活选择父类，因为决定你的 controller 继承什么父类的，不是切面中的代码，而是 controller 本身处理什么逻辑。


### 面相接口编程
接口，在表面上是由几个没有主体代码的方法定义组成的集合体，有唯一的名称，可以被类或其他接口所实现（或者也可以说继承）。它在形式上可能是如下的样子：

```
interface InterfaceName
{
    void Method1();
    void Method2(int para1);
    void Method3(string para2,string para3);
}
```
#### 接口的本质
那么，接口的本质是什么呢？或者说接口存在的意义是什么。我认为可以从以下两个视角考虑：

1. 接口是一组规则的集合，它规定了实现本接口的类或接口必须拥有的一组规则。体现了自然界 “如果你是…… 则必须能……” 的理念。


    例如，在自然界中，人都能吃饭，即 “如果你是人，则必须能吃饭”。那么模拟到计算机程序中，就应该有一个 IPerson（习惯上，接口名由“I” 开头）接口，并有一个方法叫 Eat()，然后我们规定，每一个表示 “人” 的类，必须实现 IPerson 接口，这就模拟了自然界 “如果你是人，则必须能吃饭” 这条规则。


2. 接口是在一定粒度视图上同类事物的抽象表示。注意这里我强调了在一定粒度视图上，因为 “同类事物” 这个概念是相对的，它因为粒度视图不同而不同。

    例如，在我的眼里，我和猪有本质区别，但是，如果在一个动物学家眼里，我和猪应该是同类，因为我们都是动物，他可以认为 “人” 和“猪”都实现了 IAnimal 这个接口，而他在研究动物行为时，不会把我和猪分开对待，而会从 “动物” 这个较大的粒度上研究，但他会认为我和一棵树有本质区别。

    现在换了一个遗传学家，因为生物都能遗传，所以在他眼里，我不仅和猪没区别，和一颗树、乃至一个 SARS 病毒都没什么区别，因为他会认为我们都实现了 IDescendable 这个接口，即我们都是可遗传的东西，他不会分别研究我们，而会将所有生物作为同类进行研究，在他眼里没有人和病毒之分，只有可遗传的物质和不可遗传的物质。


#### 面向接口编程综述

在系统分析和架构中，分清层次和依赖关系，每个层次不是直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类。

这样做的好处是显而易见的，首先对系统灵活性大有好处。当下层需要改变时，只要接口及接口功能不变，则上层不用做任何修改。甚至可以在不改动上层代码时将下层整个替换掉，就像我们将一个 WD 的 60G 硬盘换成一个希捷的 160G 的硬盘，计算机其他地方不用做任何改动，而是把原硬盘拔下来、新硬盘插上就行了，因为计算机其他部分不依赖具体硬盘，而只依赖一个 IDE 接口，只要硬盘实现了这个接口，就可以替换上去。从这里看，程序中的接口和现实中的接口极为相似！

使用接口的另一个好处就是不同部件或层次的开发人员可以并行开工，就像造硬盘的不用等造 CPU 的，也不用等造显示器的，只要接口一致，设计合理，完全可以并行进行开发，从而提高效率。

#### 面相接口编程实现

* 依赖倒置

    上层模块不应该依赖于下层模块，它们共同依赖于一个抽象。
    抽象不能依赖于具象，具象依赖于抽象。 　　

* 控制反转

* 依赖注入

### 其它
#### 什么是多态

指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式（发送消息就是函数调用）。实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。我们可以简单的理解为生活中的双标。

多态有两种表现形式：重载和覆盖
* 首先说重载（overload），是发生在同一类中。与什么父类子类、继承毫无关系。标识一个函数除了函数名外，还有函数的参数（个数和类型）。也就是说，一个类中可以有两个或更多的函数，叫同一个名字而他们的参数不同。
他们之间毫无关系，是不同的函数，只是可能他们的功能类似，所以才命名一样，增加可读性，仅此而已！
* 再说覆盖(override),是发生在子类中！也就是说必须有继承的情况下才有覆盖发生。我们知道继承一个类，也就有了父类了全部方法，如果你感到哪个方法不爽，功能要变，那就把那个函数在子类中重新实现一遍。这样再调用这个方法的时候，就是执行子类中的过程了。父类中的函数就被覆盖了。（当然，覆盖的时候函数名和参数要和父类中完全一样,不然你的方法对父类中的方法就不起任何作用，因为两者是两个函数，毫不关系）

### 参考文档
[面相接口编程](https://www.cnblogs.com/leoo2sk/archive/2008/04/10/1146447.html)

[理解面向过程（OPP）、面向对象（OOP）、面向切面（AOP）](https://www.cnblogs.com/minigrasshopper/p/10271758.html)








